---
title: "covid19api_vignette"
author: "Victoria Seng"
date: "9/21/2021"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

# Required Packages (will update if additional are needed)
*  `tidyverse`
*  `httr`
*  `jsonlite`
*  `stringr`
*  `lubridate`
*  `matrixStats`

# Functions
*  `getSummaryGlobal()`
*  `getSummaryCountries()`
*  `getCountries()`
*  `returnSlug()`
*  `handleTZ()`
*  `handleDT()`
*  `getDayOneLive()`
*  `getByCountryLive()`
*  `getLiveCS()`
*  `getLiveCAS()`

```{r libs, echo = FALSE, message = FALSE, results = "hide"}
library(tidyverse)
library(httr)
library(jsonlite)
library(stringr)
library(lubridate)
library(matrixStats)
```

## `getSummaryGlobal()`

Grabs the daily summary, which shows total and new cases by country and case type

```{r define_getSummaryGlobal}
getSummaryGlobal <- function(){
  resp <- GET("https://api.covid19api.com/summary")
  content <- fromJSON(rawToChar(resp$content))
  summary <- as_tibble(content$Global)
  return(summary)
}

```

```{r define_getSummaryCountries}
getSummaryCountries <- function(){
  resp <- GET("https://api.covid19api.com/summary")
  content <- fromJSON(rawToChar(resp$content))
  summary <- as_tibble(content$Countries)
  return(summary)
}

```

## `getCountries()`

Grabs all country names, slugs, and abbreviations. It is used inside all other functions where the user inputs `country` as an argument.

```{r define_getCountries}

getCountries <- function(){
  resp <- GET("https://api.covid19api.com/countries")
  countries <- as_tibble(fromJSON(rawToChar(resp$content)))
  return(countries)
}

```

## `returnSlug()`

Takes a quoted string and returns the country slug (if available) as a character string. Argument can be the name of the country, the slug, or the ISO2 abbreviation. Throws a specific error if no match is found.

```{r returnSlug}
returnSlug <- function(cntry){
  countries <- getCountries() ## grab all the countries as a tibble
  
  slug <- countries %>%
    filter(
        case_when(
          cntry %in% Country ~ cntry == Country,
          cntry %in% ISO2    ~ cntry == ISO2,
          cntry %in% Slug    ~ cntry == Slug
      ) ## figure out which column the argument is referencing, then filter to the correct row 
    ) %>% 
      select(Slug) ## grab the slug
  
  if(nrow(slug) == 0) stop(
    paste0(
      cntry, " is not a country name, slug, or ISO2 value supported by the api"
    ) ## if there is no match, the resulting tibble will have 0 rows. Throw an error if this happens
  )
  
  return(unname(unlist(slug))) ## turn the slug into a character string and return it
}

```

## `handleTZ()`

This function takes a character string and tries to find a match in `OlsonNames()`. If an exact match cannot be found, a partial match is searched for. If one is found, it is used, but a warning is thrown. If that cannot be found, the function returns a TZ of "UTC" and throws a warning.

```{r define_handleTZ}
handleTZ <- function(z = "UTC"){
  #handle the time zone
  olson <- OlsonNames()
  zone <- if(z %in% olson) {z} else {NULL} # if the zone is an exact match, use it
  
  found <- if(is_null(zone)) {
    unlist(
      lapply(
        olson, function(x){
          if(grepl(z, x)) {x} else {NULL}
        }
      )
    )
  } # if not, search for a matching string within olson.
  
  if(is_null(zone) & (length(found) > 1 | is_null(found))) {
    zone <- "UTC"
    warning(
      paste0(z, " is not a recognized time zone. Defaulting to UTC.")
    ) # If no match or too many matches are found, just use UTC. But warn the user.
  } else if(is_null(zone) & length(found) == 1) {
    zone <- found
    warning(
      paste0(z, " is not a recognized time zone. Using closest match, ", found, ".")
    ) # if a single match is found, use it. But warn the user.
  }
  return(zone)
}
```

## `handleDT()`

```{r define_handleDT}

handleDT <- function(date, z){
  zone <- if(!is_null(z)){handleTZ(z)} else {"UTC"} # handle the time zone
  dt <- str_replace_all(date, "/", "-") #preliminary data cleaning
  
  cleanDT <- if(
    str_detect(
      dt, "^[:digit:]{4}-[:digit:]{2}-[:digit:]{2}([:space:]|T)[:digit:]{2}:[:digit:]{2}:[:digit:]{2}"
    )
  ) {ymd_hms(dt, tz = zone)} else if(
    str_detect(
      dt, "^[:digit:]{4}-[:digit:]{2}-[:digit:]{2}([:space:]|T)[:digit:]{2}:[:digit:]{2}"
    )
  ) {ymd_hm(dt, tz = zone)} else if(
    str_detect(
      dt, "^[:digit:]{4}-[:digit:]{2}-[:digit:]{2}([:space:]|T)[:digit:]{2}"
    )
  ) {ymd_h(dt, tz = zone)} else if(
    str_detect(
      dt, "^[:digit:]{4}-[:digit:]{2}-[:digit:]{2}"
    )
  ) {ymd(dt, tz = zone)} else {stop(paste0("Could not parse ", date, " into a datetime object."))}
  
  cleanUTC <- toString(if(zone != "UTC") {with_tz(cleanDT, "UTC")} else {cleanDT}) # translate to UTC if needed
  dtStr <- paste0(substr(cleanUTC,1,10),"T", substr(cleanUTC,12,19),"Z")
  return(dtStr)
}

```

## `getDayOneLive()`

This endpoint returns all cases of the specified case type for the specified country from its first recorded case to present (updated every 10 minutes.)

Its arguments are `country` and `caseType`.

TO DO: figure out if there is an all option to this endpoint. If there is, I'll need to have these be unnamed args and add logic to accommodate.

```{r define_getDayOneLive}
getDayOneLive <- function(country, caseType){
  resp <- GET(
    paste0(
      "https://api.covid19api.com/dayone/country/",returnSlug(country),"/status/",caseType,"/live"
    )
  )
  df <- as_tibble(fromJSON(rawToChar(resp$content)))
  return(df)
}
```

## `getCountryLive()`

Takes a country, from datetime string, and optionally a to and time zone string

```{r define_getCountryLive}
getCountryLive <- function(country, from, to = NULL, z = NULL){
  params <- paste0(
    returnSlug(country),"/status/confirmed/live?from=",handleDT(from, z)
  )
  if(!is_null(to)){params <- paste0(params, "&to=", handleDT(to, z))}
  
  resp <- GET(
    paste0(
      "https://api.covid19api.com/country/", params
    )
  )
  df <- as_tibble(fromJSON(rawToChar(resp$content)))
  return(df)
}

```

## `getLiveCS()`

takes country, case type

```{r define_getLiveCS}
getLiveCS <- function(country, caseType){
  params <- paste0(
    returnSlug(country),"/status/",caseType)
  
  resp <- GET(
    paste0(
      "https://api.covid19api.com/country/", params
    )
  )
  df <- as_tibble(fromJSON(rawToChar(resp$content)))
  return(df)
}

```

## `getLiveCAS()`

takes country name

```{r define_getLiveCAS}
getLiveCAS <- function(country){
  params <- paste0(
    returnSlug(country))
  
  resp <- GET(
    paste0(
      "https://api.covid19api.com/live/country/", params
    )
  )
  df <- as_tibble(fromJSON(rawToChar(resp$content)))
  return(df)
}

```

## `getLiveCsAfterDT()`

```{r define_getLiveCsAfterDT}
getLiveCsAfterDT <- function(country, from, z = NULL){
  params <- paste0(
    returnSlug(country),"/status/confirmed/live?from=",handleDT(from, z)
  )
  
  resp <- GET(
    paste0(
      "https://api.covid19api.com/country/", params
    )
  )
  df <- as_tibble(fromJSON(rawToChar(resp$content)))
  return(df)
}

```

# Exploratory Data Analysis (EDA)

First, let's pull the countries summary. I'd like to split the number of confirmed cases into brackets and store it as a factor. I then want to see the number of countries in each bracket as a contingency table.

```{r eda_scatter_plot}
summary <- getSummaryCountries()

df <- ggplot(data = summary) 

df + geom_point(aes(x = TotalConfirmed, y = TotalDeaths)) +
  labs(title = "Total Confirmed Cases v Total Deaths for Each Country", x = "Confirmed", y = "Deaths") +
    theme(axis.text.x = element_text(angle = 270)) +
      scale_x_continuous(labels = scales::comma) +
        scale_y_continuous(labels = scales::comma)
```

```{r eda_conTab_01}
factorLvls <- c("0-1,000", "1,000-9,999", "10,000-99,999", "100,000-999,999", "1,000,000-9,999,999", "Over 10,000,000")
bracketNums <- c(1000, 10000, 100000, 1000000, 10000000)

ccWithBrackets <- summary %>%
  select(CountryCode, TotalConfirmed, TotalDeaths) %>%
    mutate(confirmed = if_else(
      TotalConfirmed < bracketNums[1], factorLvls[1], if_else(
        TotalConfirmed < bracketNums[2], factorLvls[2], if_else(
          TotalConfirmed < bracketNums[3], factorLvls[3], if_else(
            TotalConfirmed < bracketNums[4], factorLvls[4], if_else(
              TotalConfirmed < bracketNums[5], factorLvls[5], factorLvls[6]
            )
          )
        )
      )
    ), deaths = if_else(
      TotalDeaths < bracketNums[1], factorLvls[1], if_else(
        TotalDeaths < bracketNums[2], factorLvls[2], if_else(
          TotalDeaths < bracketNums[3], factorLvls[3], if_else(
            TotalDeaths < bracketNums[4], factorLvls[4], if_else(
              TotalDeaths < bracketNums[5], factorLvls[5], factorLvls[6]
            )
          )
        )
      )
    )
  )  

table(ccWithBrackets$confirmed, ccWithBrackets$deaths)

```

```{r eda_histogram}
rows <- nrow(ccWithBrackets)

df <- ggplot(data = ccWithBrackets %>% slice_min(TotalConfirmed, n = (rows-3)))

df + geom_histogram(aes(x = TotalConfirmed), bins = 20) +
  theme(axis.text.x = element_text(angle = 270)) +
    scale_x_continuous(labels = scales::comma) 
```

```{r eda_boxplot}
summPivot <- summary %>%
  pivot_longer(cols = starts_with("Total"), names_to = "Type", values_to = "Cases", values_drop_na = TRUE) %>%
    select(CountryCode, Type, Cases) %>%
      filter(Type %in% c("TotalConfirmed", "TotalDeaths"))

ggplot(summPivot, aes(Type, Cases)) +
  geom_boxplot() +
    scale_y_continuous(labels = scales::comma) +
      labs(title = "Boxplot for Cases by Type")

```

```{r eda_bar_chart}
summSlice <-  summPivot %>% 
  slice_max(Cases , n = 10)
        

ggplot(summSlice, aes(CountryCode)) +
  geom_bar(aes(y = Cases, fill = Type), stat = "identity", position = "dodge") +
      labs(title = "Cases by Type for 10 Largest Case Counts", x = "Country", fill = "") +
        theme(axis.text.x = element_text(angle = 0)) +
          scale_y_continuous(labels = scales::comma) +
            scale_fill_brewer(palette = "Set2")
```


```{r eda_03}
top3 <- ccWithBrackets %>%
  select(CountryCode, TotalConfirmed) %>%
    slice_max(TotalConfirmed , n = 3)

top3
```

```{r eda_04}
usa <- getCountryLive("united-states", "2021-09-24T00:00:00", to = "2021-09-30T00:00:00", z = "UTC") %>%
  group_by(Province) %>%
    summarize(Cases = sum(Cases))

usaBuckets <- usa %>%
  mutate(bucket = cut(Cases, breaks = seq(0, 10000000, by = 10000)))
```

```{r eda_06}
nc <- unlist(getCountryLive("united-states", "2021-09-24T00:00:00", to = "2021-09-30T00:00:00", z = "UTC") %>%
  filter(Province == "North Carolina") %>%
    group_by(Province) %>%
      summarize(min = min(Cases), mean = mean(Cases), median = median(Cases), IQR = IQR(Cases), max = max(Cases))
)

ncCounties <- getCountryLive("united-states", "2021-09-24T00:00:00", to = "2021-09-30T00:00:00", z = "UTC") %>%
  filter(Province == "North Carolina") %>%
    group_by(Province, City) %>%
      summarize(min = min(Cases), mean = mean(Cases), median = median(Cases), IQR = IQR(Cases), max = max(Cases)) %>%
        mutate(bucket = if_else(mean <= as.numeric(nc["mean"]), "under", "over")) 

table(ncCounties$bucket)
```

```{r eda_08}
vaCounties <- getCountryLive("united-states", "2021-09-24T00:00:00", to = "2021-09-30T00:00:00", z = "UTC") %>%
  filter(Province == "Virginia") %>%
    group_by(Province, City) %>%
      summarize(min = min(Cases), mean = mean(Cases), median = median(Cases), IQR = IQR(Cases), max = max(Cases))

bothStates <- rbind(ncCounties, vaCounties)
```

```{r eda_07}

ggplot(bothStates, aes(Province, mean)) +
  geom_boxplot() +
    scale_y_continuous(labels = scales::comma) +
      labs(title = "NC vs VA: Boxplot for Mean Confirmed Cases by County 9/24-9/30")
```

A few requirements about your EDA are below:
*  You should pull data from at least two endpoints (possibly combining them into one)
*  You should create at least two new variables that are functions of the variables from a data set you use
*  You should create some contingency tables
*  You should create numerical summaries for some quantitative variables at each setting of some of your categorical variables
*  You should create at least five plots utilizing coloring, grouping, etc. All plots should have nice labels and titles.
∗  You should have at least one bar plot(done), one histogram (done), one box plot(done), and one scatter plot(done)

# Wrap Up